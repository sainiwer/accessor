package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"text/template"
)

/*
该版本可以生成指定的结构体的访问器，并且以accessor+结构体名字命名输出文件
*/
const tmpl = `// Code generated by go generate ; DO NOT EDIT.

package {{ .PackageName }}

{{ range .Fields }}
func (p *{{ .StructName }}) Get{{ .FieldName }}() {{ .FieldType }} {
    return p.{{ .FieldName }}
}

func (p *{{ .StructName }}) Set{{ .FieldName }}(value {{ .FieldType }}) {
    p.{{ .FieldName }} = value
}
{{ end }}
`

//go:generate go run generate_specail.go TinyWrapSave
type Field struct {
	StructName string
	FieldName  string
	FieldType  string
}

type Data struct {
	PackageName string
	Fields      []Field
}

func typeInfo(t ast.Expr) string {
	switch expr := t.(type) {
	case *ast.Ident:
		return expr.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", typeInfo(expr.X), expr.Sel.Name)
	case *ast.ArrayType:
		return fmt.Sprintf("[]%s", typeInfo(expr.Elt))
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", typeInfo(expr.Key), typeInfo(expr.Value))
	case *ast.StarExpr: // 处理指针类型
		return fmt.Sprintf("*%s", typeInfo(expr.X))
	default:
		return fmt.Sprintf("%s", t) // 返回原始表达式
	}
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run generate.go <StructName>")
		return
	}

	structNameToGenerate := os.Args[1] // 获取命令行参数

	fset := token.NewFileSet()
	node, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		fmt.Println(err)
		return
	}

	var data Data

	for pkgName, pkg := range node {
		data.PackageName = pkgName // 提取包名
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				ts, ok := n.(*ast.TypeSpec)
				if ok {
					structType, ok := ts.Type.(*ast.StructType)
					if ok {
						structName := ts.Name.Name
						if structName != structNameToGenerate {
							return true // 只处理指定结构体
						}
						for _, field := range structType.Fields.List {
							for _, name := range field.Names {
								data.Fields = append(data.Fields, Field{
									StructName: structName,
									FieldName:  name.Name,
									FieldType:  typeInfo(field.Type), // 使用 typeInfo 函数
								})
							}
						}
					}
				}
				return true
			})
		}
	}

	if len(data.Fields) == 0 {
		fmt.Println("No struct fields found for", structNameToGenerate)
		return
	}

	outputFileName := fmt.Sprintf("accessor_%s.go", structNameToGenerate)
	outputFile, err := os.Create(outputFileName)
	//outputFile, err := os.Create("struct_accessor.go")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer func(outputFile *os.File) {
		err := outputFile.Close()
		if err != nil {

		}
	}(outputFile)

	must := template.Must(template.New("methods").Parse(tmpl))
	if err := must.Execute(outputFile, data); err != nil {
		fmt.Println(err)
	}
}
