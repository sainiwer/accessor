package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"text/template"
)

/*
该版本可以生成指定的结构体的访问器，并且以accessor+结构体名字命名输出文件
*/

const GetAndSet = `// Code generated by go generate ; DO NOT EDIT.

package {{ .PackageName }}

{{ range .Fields }}
func (p *{{ .StructName }}) Get{{ .FieldName }}() {{ .FieldType }} {
    return p.{{ .FieldName }}
}

func (p *{{ .StructName }}) Set{{ .FieldName }}(value {{ .FieldType }}) {
    p.{{ .FieldName }} = value
}
{{ end }}
`

const tmplSet = `// Code generated by go generate ; DO NOT EDIT.

package {{ .PackageName }}

{{ range .Fields }}


func (p *{{ .StructName }}) Set{{ .FieldName }}(value {{ .FieldType }}) {
    p.{{ .FieldName }} = value
}
{{ end }}
`

const tmplGet = `// Code generated by go generate ; DO NOT EDIT.

package {{ .PackageName }}

{{ range .Fields }}

func (p *{{ .StructName }}) Get{{ .FieldName }}() {{ .FieldType }} {
    return p.{{ .FieldName }}
}

{{ end }}
`

var (
	data        Data
	specifyStr  string
	operation   string
	inspectFunc func(n ast.Node) bool
)

func init() {
	inspectFunc = func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok {
			if structType, ok := ts.Type.(*ast.StructType); ok {
				structName := ts.Name.Name
				if structName != specifyStr {
					return true // 只处理指定结构体
				}
				for _, field := range structType.Fields.List {
					for _, name := range field.Names {
						data.Fields = append(data.Fields, Field{
							StructName: structName,
							FieldName:  name.Name,
							FieldType:  typeInfo(field.Type), // 使用 typeInfo 函数
						})
					}
				}
			}
		}
		return true
	}
}

type Field struct {
	StructName string
	FieldName  string
	FieldType  string
}

type Data struct {
	PackageName string
	Fields      []Field
}

func typeInfo(t ast.Expr) string {
	switch expr := t.(type) {
	default:
		panic(fmt.Sprintf("no this case to deal!!%s", t))
		//return fmt.Sprintf("%s", t) // 返回原始表达式
	case *ast.Ident:
		return expr.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", typeInfo(expr.X), expr.Sel.Name)
	case *ast.ArrayType:
		return fmt.Sprintf("[]%s", typeInfo(expr.Elt))
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", typeInfo(expr.Key), typeInfo(expr.Value))
	case *ast.StarExpr: // 处理指针类型
		return fmt.Sprintf("*%s", typeInfo(expr.X))
	case *ast.ChanType:
		return fmt.Sprintf("chan %s", typeInfo(expr.Value)) // 处理chan类型
	}
}

func formatCode(filename string) error {
	cmd := exec.Command("go", "fmt", filename)
	return cmd.Run()
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run generate.go <StructName>")
		return
	}

	specifyStr = os.Args[1] // 获取命令行参数

	if len(os.Args) == 3 {
		operation = os.Args[2] //生成操作的指示 set,get none
	}
	fileSet := token.NewFileSet()
	node, err := parser.ParseDir(fileSet, ".", nil, parser.ParseComments)
	if err != nil {
		fmt.Println(err)
		return
	}

	for pkgName, pkg := range node {
		data.PackageName = pkgName // 提取包名
		for _, file := range pkg.Files {
			ast.Inspect(file, inspectFunc)
		}
	}

	if len(data.Fields) == 0 {
		fmt.Printf("No struct fields found for %v!\n", specifyStr)
		return
	}

	//设置指定的文件名并创建文件
	outFileName := fmt.Sprintf("accessor_%s.go", specifyStr)
	outFile, err := os.Create(outFileName)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer func(out *os.File) {
		if err := out.Close(); err != nil {
			fmt.Printf("out file close is fail err = %v\n", err)
		}
	}(outFile)

	templateOp := getOperationTemplate(operation)
	must := template.Must(template.New("methods").Parse(templateOp))

	if err := must.Execute(outFile, data); err != nil {
		fmt.Printf("out file Execute is fail err = %v\n", err)
		return
	}
	fmt.Printf("\n generate struct %v's accessor is success !\n", specifyStr)

	// 运行 go fmt
	if err = formatCode(outFileName); err != nil {
		fmt.Println("格式化失败:", err)
	}
}

// get the generated template based on command line parameters
func getOperationTemplate(operation string) string {
	var templateOp string
	switch operation {
	default:
		templateOp = GetAndSet
	case "set":
		templateOp = tmplSet
	case "get":
		templateOp = tmplGet
	}
	return templateOp
}
